% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcp.R
\name{mcp}
\alias{mcp}
\title{Fit Multiple Linear Segments And Their Change Points}
\usage{
mcp(
  segments,
  data = NULL,
  prior = list(),
  family = gaussian(),
  par_x = NULL,
  sample = "post",
  cores = 1,
  chains = 3,
  iter = 3000,
  adapt = 1000,
  inits = NULL,
  jags_code = NULL
)
}
\arguments{
\item{segments}{A list of formulas - one for each segment. The first formula
has the format \code{response ~ predictors} while the following formulas
have the format \code{response ~ changepoint ~ predictors}. The response
and change points can be omitted (\code{changepoint ~ predictors} assumes same
response. \code{~ predictors} assumes an intercept-only change point). Segments
can model
\itemize{
\item \emph{Regular formulas:} e.g., \code{~ 0 + x + I(x^2) + exp(x)}). \href{https://lindeloev.github.io/mcp/articles/formulas.html}{Read more here}.
\item \emph{Variance:} e.g., \code{~sigma(1)} for a simple variance change or
\code{~sigma(rel(1) + I(x^2))}) for more advanced variance structures. \href{https://lindeloev.github.io/mcp/articles/variance.html}{Read more here}
\item \emph{Autoregression:} e.g., \code{~ar(1)} for a simple onset/change in AR(1) or
\verb{ar(2, 0 + x}) for an AR(2) with parameter(s) increasing by \code{x}. \href{https://lindeloev.github.io/mcp/articles/arma.html}{Read more here}
}}

\item{data}{Data.frame or tibble in long format.}

\item{prior}{Named list. Names are parameter names (\code{cp_i}, \code{int_i}, \code{xvar_i},
`sigma``) and the values are either
\itemize{
\item A JAGS distribution (e.g., \code{int_1 = "dnorm(0, 1) T(0,)"}) indicating a
conventional prior distribution. Uninformative priors based on data
properties are used where priors are not specified. This ensures good
parameter estimations, but it is a questionable for hypothesis testing.
\code{mcp} uses SD (not precision) for dnorm, dt, dlogis, etc. See
details. Change points are forced to be ordered through the priors using
truncation, except for uniform priors where the lower bound should be
greater than the previous change point, \code{dunif(cp_1, MAXX)}.
\item A numerical value (e.g., \code{int_1 = -2.1}) indicating a fixed value.
\item A model parameter name (e.g., \code{int_2 = "int_1"}), indicating that this parameter is shared -
typically between segments. If two varying effects are shared this way,
they will need to have the same grouping variable.
}}

\item{family}{One of \code{gaussian()}, \code{binomial()}, \code{bernoulli()}, or \code{poission()}.
Only default link functions are currently supported.}

\item{par_x}{String (default: NULL). Only relevant if no segments contains
slope (no hint at what x is). Set this, e.g., par_x = "time".}

\item{sample}{One of
\itemize{
\item \code{"post"} (default): Sample the posterior.
\item \code{"prior"}: Sample only the prior. Plots, summaries, etc. will
use the prior. This is useful for prior predictive checks.
\item \code{"both"}: Sample both prior and posterior. Plots, summaries, etc.
will default to using the posterior. The prior only has effect when doing
Savage-Dickey density ratios in \code{\link{hypothesis}}.
\item \code{"none"} or \code{FALSE}: Do not sample. Returns an mcpfit
object without sample. This is useful if you only want to check
prior strings (fit$prior), the JAGS model (fit$jags_code), etc.
}}

\item{cores}{Positive integer or "all". Number of cores.
\itemize{
\item \code{1}: serial sampling
\item \verb{>1}: parallel sampling on this number of cores. Ideally set \code{chains}
to the same value. Note: \code{cores > 1} takes a few extra seconds the first
time it's called but subsequent calls will start sampling immediately.
\item \code{"all"}: use all cores but one and sets \code{chains} to the same value. This is
a convenient way to maximally use your computer's power.
}}

\item{chains}{Positive integer. Number of chains to run.}

\item{iter}{Positive integer. Number of post-warmup samples to draw.}

\item{adapt}{Positive integer. Also sometimes called "burnin", this is the
number of samples used to reach convergence. Set lower for greater speed.
Set higher if the chains haven't converged yet or look at \href{https://lindeloev.github.io/mcp/articles/tips.html}{tips, tricks, and debugging}.}

\item{inits}{A list if initial values for the parameters. This can be useful
if a model fails to converge. Read more in \code{\link[rjags]{jags.model}}.
Defaults to \code{NULL}, i.e., no inits.}

\item{jags_code}{Pass JAGS code to \code{mcp} to use directly. This is useful if
you want to tweak the code in \code{fit$jags_code} and run it within the \code{mcp}
framework.}
}
\value{
An \code{mcpfit} object.
}
\description{
Given a list of linear segments, \code{mcp} infers the posterior
distributions of the parameters of each segment as well as the change points
between segments. \href{https://lindeloev.github.io/mcp/}{See more details and worked examples on the mcp website}.
All segments must regress on the same x-variable. Change
points are forced to be ordered using truncation of the priors. You can run
\code{fit = mcp(segments, sample=FALSE)} to avoid sampling and the need for
data if you just want to get the priors (\code{fit$prior}), the JAGS code
\code{fit$jags_code}, or the R function to simulate data (\code{fit$simulate}).
}
\details{
Notes on priors:
\itemize{
\item Order restriction is automatically applied to cp_\* parameters using
truncation (e.g., \code{T(cp_1, )}) so that they are in the correct order on the
x-axis UNLESS you do it yourself. The one exception is for dunif
distributions where you have to do it as above.
\item In addition to the model parameters, \code{MINX} (minimum x-value), \code{MAXX}
(maximum x-value), \code{SDX} (etc...), \code{MINY}, \code{MAXY}, and \code{SDY}
are also available when you set priors. They are used to set uninformative
default priors.
\item Use SD when you specify priors for dt, dlogis, etc. JAGS uses precision
but \code{mcp} converts to precision under the hood via the sd_to_prec()
function. So you will see SDs in \code{fit$prior} but precision ($1/SD^2)
in \code{fit$jags_code}
}
}
\examples{
\dontrun{
# Define the segments that are separated by change points
segments = list(
  score ~ 1 + year,  # intercept + slope
   ~ 0 + year,  # joined slope
   ~ 0,  # joined plateau
   ~ 1  # disjoined plateau
)

# Sample and see results
fit = mcp(segments, data)
summary(fit)

# Visual inspection of the results
plot(fit)
plot_pars(fit)

# Test a hypothesis
hypothesis(fit, "cp_1 > 10")

# Compare to a one-intercept-only model (no change points) with default prior
segments2 = list(score ~ 1)
fit2 = mcp(segments2, data)  # fit another model here
fit$loo = loo(fit)
fit2$loo = loo(fit)
loo_compare(fit, fit2)

# Sample the prior and inspect it using all the usual methods (prior predictive checks)
fit_prior = mcp(segments, data, sample = "prior")
summary(fit_prior)
plot(fit_prior)

# Show all priors. Default priors are added where you don't provide any
fit$prior

# Set priors and re-run
# cp_i are change points.
# int_i are intercepts.
# x_i are slopes.
# i is the segment number (change points are to the right of the segment)
prior = list(
  int_1 = "dt(10, 30) T(0, )",  # t-dist intercept. Truncated to > 0
  year_1 = "dnorm(0, 5)",  # slope of segment 1. Mean = 0, SD = 5.
  cp_2 = "dunif(cp_1, 40)",  # change point to segment 2 > cp_1.
  year_2 = "year_1",  # Shared slope between segment 2 and 1
  int_3 = 15  # Fixed intercept of segment 3
)
fit3 = mcp(segments, data, prior)

# Show JAGS model
cat(fit$jags_code)
}
}
\seealso{
\link{get_segment_table}
}
\author{
Jonas Kristoffer Lindel√∏v \email{jonas@lindeloev.dk}
}
